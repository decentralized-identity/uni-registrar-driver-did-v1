/**
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const LinkedDataSignature = require('./LinkedDataSignature');
const util = require('../util');

module.exports = class RsaSignature2018 extends LinkedDataSignature {
  constructor(injector) {
    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'RsaSignature2018';

    super(injector, algorithm);
    this.requiredKeyType = 'RsaVerificationKey2018';
  }

  createSignatureValue(verifyData, options) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const forge = _this.injector.use('forge');

      // TODO: should abstract JWS signing bits out for reuse elsewhere

      // JWS header
      const header = _this.createJwsHeader();

      /*
      +-------+-----------------------------------------------------------+
      | "b64" | JWS Signing Input Formula                                 |
      +-------+-----------------------------------------------------------+
      | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |
      |       | BASE64URL(JWS Payload))                                   |
      |       |                                                           |
      | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |
      |       | JWS Payload                                               |
      +-------+-----------------------------------------------------------+
      */

      const encodedHeader = util.encodeBase64Url(JSON.stringify(header), { forge });

      let encodedSignature;
      if (_this.injector.env.nodejs) {
        // FIXME: better abstract for future suites

        // optimize using node 8.0+ libraries
        const crypto = _this.injector.use('crypto');
        if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {
          const signer = crypto.createSign('RSA-SHA256');

          // build signing input per above comment
          signer.update(encodedHeader + '.', 'utf8');
          signer.update(new Buffer(verifyData.data, verifyData.encoding));
          const buffer = signer.sign(Object.assign({
            key: options.privateKeyPem
          }, _this.createPss()));
          encodedSignature = util.encodeBase64Url(buffer.toString('binary'), { forge });
        }
      }

      if (!encodedSignature) {
        // browser or other environment (including node 6.x)
        const privateKey = forge.pki.privateKeyFromPem(options.privateKeyPem);
        const md = forge.md.sha256.create();
        // build signing input per above comment
        md.update(encodedHeader + '.', 'utf8');
        md.update(verifyData.data, verifyData.encoding);
        const pss = _this.createPss(forge);
        const binaryString = privateKey.sign(md, pss);
        encodedSignature = util.encodeBase64Url(binaryString, { forge });
      }

      // create detached content signature
      return encodedHeader + '..' + encodedSignature;
    })();
  }

  verifyProofNode(verifyData, proof, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const forge = _this2.injector.use('forge');

      const publicKeyPem = options.publicKey.publicKeyPem;

      // add payload into detached content signature

      var _proof$jws$split = proof.jws.split('.'),
          _proof$jws$split2 = _slicedToArray(_proof$jws$split, 3);

      const encodedHeader = _proof$jws$split2[0],
            payload = _proof$jws$split2[1],
            encodedSignature = _proof$jws$split2[2];


      const header = JSON.parse(util.decodeBase64Url(encodedHeader, { forge }));
      if (!(header && typeof header === 'object')) {
        throw new Error('Invalid JWS header.');
      }

      // confirm header matches all expectations
      _this2.checkJwsHeader(header);

      const rawSignature = util.decodeBase64Url(encodedSignature, { forge });

      if (_this2.injector.env.nodejs) {
        // optimize using node 8.0+ libraries
        const crypto = _this2.injector.use('crypto');
        if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {
          const crypto = _this2.injector.use('crypto');
          const verifier = crypto.createVerify('RSA-SHA256');
          // rebuild signing input per JWS spec
          verifier.update(encodedHeader + '.', 'utf8');
          verifier.update(new Buffer(verifyData.data, verifyData.encoding));
          return verifier.verify(Object.assign({
            key: publicKeyPem
          }, _this2.createPss()), new Buffer(rawSignature, 'binary'));
        }
      }

      // browser or other environment
      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
      const md = forge.md.sha256.create();
      // rebuild signing input per JWS spec
      md.update(encodedHeader + '.', 'utf8');
      md.update(verifyData.data, verifyData.encoding);
      return publicKey.verify(md.digest().bytes(), rawSignature, _this2.createPss(forge));
    })();
  }

  validateKey(key, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (typeof key.publicKeyPem !== 'string') {
        throw new TypeError('Unknown public key encoding. Public key encoding must be ' + '"publicKeyPem".');
      }
      const jsonld = _this3.injector.use('jsonld');
      if (!jsonld.hasValue(key, 'type', _this3.requiredKeyType)) {
        throw new TypeError(`Invalid key type. Key type must be "${_this3.requiredKeyType}".`);
      }
    })();
  }

  createJwsHeader() {
    const header = {
      alg: 'PS256',
      b64: false,
      crit: ['b64']
    };
    return header;
  }

  checkJwsHeader(header) {
    /*
    const expectedHeader = {
      alg: 'PS256',
      b64: false,
      crit: ['b64']
    };
    */
    if (!(header.alg === 'PS256' && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === 'b64') && Object.keys(header).length === 3) {
      throw new Error('Invalid JWS header parameters for RsaSignature2018.');
    }
  }

  createPss(forge) {
    // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,
    // https://tools.ietf.org/html/rfc7518

    // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,
    // a SHA-256 based masking function MGF1, and a 32 byte salt to match
    // the hash size
    if (forge) {
      const md = forge.md.sha256.create();
      return forge.pss.create({
        md,
        mgf: forge.mgf.mgf1.create(forge.md.sha256.create()),
        saltLength: md.digestLength
      });
    } else {
      const crypto = require('crypto');
      return {
        padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
      };
    }
  }
};