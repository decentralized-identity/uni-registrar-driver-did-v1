/*
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const constants = require('../constants');
const util = require('../util');
const LinkedDataSignature = require('./LinkedDataSignature');

module.exports = class LinkedDataSignature2015 extends LinkedDataSignature {
  constructor(injector) {
    let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'LinkedDataSignature2015';

    super(injector, algorithm);
  }

  createProofNode(verifyData, options) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const proof = options.proof;
      proof.signatureValue = yield _this.createSignatureValue(verifyData, options);
      return proof;
    })();
  }

  attachProofNode(input, proofNode, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // compact proof node to match input context
      const tmp = {
        'https://w3id.org/security#signature': proofNode
      };
      const jsonld = _this2.injector.use('jsonld');
      const ctx = jsonld.getValues(input, '@context');
      const opts = { expansionMap: options.expansionMap };
      if (options.documentLoader) {
        opts.documentLoader = options.documentLoader;
      }
      const compactProofNode = yield jsonld.compact(tmp, ctx, opts);

      // TODO: it is unclear how the signature would be easily added without
      // reshaping the input... so perhaps this library should just require
      // the caller to accept that the signature will be added to the top
      // level of the input

      // attach signature node to cloned input and return it
      const output = util.deepClone(input);
      delete compactProofNode['@context'];
      const proofKey = Object.keys(compactProofNode)[0];
      jsonld.addValue(output, proofKey, compactProofNode[proofKey]);
      return output;
    })();
  }

  createSignatureValue(verifyData, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      // TODO: support `sign` function via options instead of `privateKeyPem`
      if (typeof options.privateKeyPem !== 'string') {
        throw new TypeError('"options.privateKeyPem" must be a PEM formatted string.');
      }

      if (_this3.injector.env.nodejs) {
        // optimize using node libraries
        const crypto = _this3.injector.use('crypto');
        const signer = crypto.createSign('RSA-SHA256');
        signer.update(verifyData.data, verifyData.encoding);
        return signer.sign(options.privateKeyPem, 'base64');
      }

      // browser or other environment
      const forge = _this3.injector.use('forge');
      const privateKey = forge.pki.privateKeyFromPem(options.privateKeyPem);
      const md = forge.md.sha256.create();
      md.update(verifyData.data, verifyData.encoding);
      return forge.util.encode64(privateKey.sign(md));
    })();
  }

  createVerifyData(input, options) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      // TODO: frame before getting signature, not just compact? considerations:
      // should the assumption be (for this library) that the signature is on
      // the top-level object and thus framing is unnecessary?

      const jsonld = _this4.injector.use('jsonld');
      const opts = { expansionMap: options.expansionMap };
      if (options.documentLoader) {
        opts.documentLoader = options.documentLoader;
      }
      const compacted = yield jsonld.compact(input, constants.SECURITY_CONTEXT_URL, opts);

      // TODO: will need to preserve `signature` when chained signature
      // option is used and implemented in the future

      // delete the existing signature(s) prior to canonicalization
      delete compacted.signature;

      const c14n = yield _this4.canonize(compacted, options);

      let verifyData = '';
      const headers = {
        'http://purl.org/dc/elements/1.1/created': options.date,
        'https://w3id.org/security#domain': options.domain,
        'https://w3id.org/security#nonce': options.nonce
      };
      // add headers in lexicographical order
      const keys = Object.keys(headers).sort();
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = headers[key];
        if (!(value === null || value === undefined)) {
          verifyData += key + ': ' + value + '\n';
        }
      }
      verifyData += c14n;
      return {
        data: verifyData,
        encoding: 'utf8'
      };
    })();
  }

  verifyProofNode(verifyData, proof, options) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const publicKeyPem = options.publicKey.publicKeyPem;
      if (typeof publicKeyPem !== 'string') {
        throw new TypeError('Could not verify signature; invalid "publicKeyPem".');
      }

      if (_this5.injector.env.nodejs) {
        // optimize using node libraries
        const crypto = _this5.injector.use('crypto');
        const verifier = crypto.createVerify('RSA-SHA256');
        verifier.update(verifyData.data, verifyData.encoding);
        return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');
      }

      // browser or other environment
      const forge = _this5.injector.use('forge');
      const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
      const md = forge.md.sha256.create();
      md.update(verifyData.data, verifyData.encoding);
      return publicKey.verify(md.digest().bytes(), forge.util.decode64(proof.signatureValue));
    })();
  }

  validateKey(key, options) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      if (typeof key.publicKeyPem !== 'string') {
        throw new TypeError('Unknown public key encoding. Public key encoding must be ' + '"publicKeyPem".');
      }
      const jsonld = _this6.injector.use('jsonld');
      if (!jsonld.hasValue(key, 'type', 'CryptographicKey')) {
        throw new TypeError('Invalid key type. Key type must be "CryptographicKey".');
      }
    })();
  }
};