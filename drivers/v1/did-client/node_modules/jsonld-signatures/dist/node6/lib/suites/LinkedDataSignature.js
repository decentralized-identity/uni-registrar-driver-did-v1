/*
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const constants = require('../constants');
const util = require('../util');
const Helper = require('../Helper');

// TODO: reorganize this class further and make it more obvious which
// methods need to be extended in proof plugins

// TODO: make signature and verification code (and potentially other code)
// more DRY, especially wrt. plugins having reimplement functionality

module.exports = class LinkedDataSignature {
  constructor(injector, algorithm) {
    this.injector = injector;
    this.algorithm = algorithm;
    this.helper = new Helper(injector);
  }

  canonize(input, options) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const jsonld = _this.injector.use('jsonld');
      const opts = {
        algorithm: 'URDNA2015',
        format: 'application/n-quads',
        expansionMap: options.expansionMap
      };
      if (options.documentLoader) {
        opts.documentLoader = options.documentLoader;
      }
      return jsonld.canonize(input, opts);
    })();
  }

  createVerifyData(input, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      // TODO: frame before getting signature, not just compact? considerations:
      // should the assumption be (for this library) that the signature is on
      // the top-level object and thus framing is unnecessary?

      const jsonld = _this2.injector.use('jsonld');
      const opts = { expansionMap: options.expansionMap };
      if (options.documentLoader) {
        opts.documentLoader = options.documentLoader;
      }
      const compacted = yield jsonld.compact(input, constants.SECURITY_CONTEXT_URL, opts);

      // TODO: will need to preserve `proof` when chained signature
      // option is used and implemented in the future

      // delete the existing proofs(s) prior to canonicalization
      delete compacted.proof;

      // ensure signature values are removed from proof node
      const proof = yield _this2.sanitizeProofNode(options.proof, options);

      // concatenate hash of c14n proof options and hash of c14n document
      const c14nProofOptions = yield _this2.canonize(proof, options);
      const c14nDocument = yield _this2.canonize(compacted, options);
      return {
        data: _this2._sha256(c14nProofOptions).getBytes() + _this2._sha256(c14nDocument).getBytes(),
        encoding: 'binary'
      };
    })();
  }

  sanitizeProofNode(proof, options) {
    return _asyncToGenerator(function* () {
      // `jws`,`signatureValue`,`proofValue` must not be included in the proof
      // options
      proof = util.deepClone(proof);
      delete proof.jws;
      delete proof.signatureValue;
      delete proof.proofValue;
      return proof;
    })();
  }

  sign(input, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      // copy options for setting defaults
      options = Object.assign({}, options || {});

      // validate common options
      if (options.creator !== undefined && typeof options.creator !== 'string') {
        throw new TypeError('"options.creator" must be a URL string.');
      }
      if (options.domain !== undefined && typeof options.domain !== 'string') {
        throw new TypeError('"options.domain" must be a string.');
      }
      if (options.nonce !== undefined && typeof options.nonce !== 'string') {
        throw new TypeError('"options.nonce" must be a string.');
      }

      // disallow dropping properties when expanding by default
      if (options.expansionMap !== false) {
        options.expansionMap = function (info) {
          if (info.unmappedProperty) {
            throw new Error('The property "' + info.unmappedProperty + '" in the input ' + 'was not defined in the context.');
          }
        };
      }

      // build proof (aka signature options)
      let proof;
      if (options.proof) {
        // use proof JSON-LD document passed to API
        const jsonld = _this3.injector.use('jsonld');
        const opts = { expansionMap: options.expansionMap };
        if (options.documentLoader) {
          opts.documentLoader = options.documentLoader;
        }
        proof = yield jsonld.compact(options.proof, constants.SECURITY_CONTEXT_URL, opts);
      } else {
        // create proof JSON-LD document
        proof = { '@context': constants.SECURITY_CONTEXT_URL };
      }

      // set default `now` date if not given in `proof` or `options`
      if (proof.created === undefined && options.date === undefined) {
        options.date = new Date();
      }

      // ensure date is in string format
      if (options.date !== undefined && typeof options.date !== 'string') {
        // TODO: parse non-string date and force to w3c format?
        options.date = util.w3cDate(options.date);
      }

      // ensure algorithm is set
      proof.type = options.algorithm;

      // add API overrides
      if (options.date !== undefined) {
        proof.created = options.date;
      }
      if (options.creator !== undefined) {
        proof.creator = options.creator;
      }
      if (options.domain !== undefined) {
        proof.domain = options.domain;
      }
      if (options.nonce !== undefined) {
        proof.nonce = options.nonce;
      }

      // produce data to sign
      options.proof = proof;
      const verifyData = yield _this3.createVerifyData(input, options);

      // create proof node
      const proofNode = yield _this3.createProofNode(verifyData, options);

      // attach proof node
      return _this3.attachProofNode(input, proofNode, options);
    })();
  }

  createProofNode(verifyData, options) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const proof = options.proof;
      proof.jws = yield _this4.createSignatureValue(verifyData, options);
      return proof;
    })();
  }

  attachProofNode(input, proofNode, options) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      // compact proof node to match input context
      const tmp = {
        'https://w3id.org/security#proof': {
          '@graph': proofNode
        }
      };
      const jsonld = _this5.injector.use('jsonld');
      const ctx = jsonld.getValues(input, '@context');
      const opts = { expansionMap: options.expansionMap };
      if (options.documentLoader) {
        opts.documentLoader = options.documentLoader;
      }
      const compactProofNode = yield jsonld.compact(tmp, ctx, opts);

      // TODO: it is unclear how the signature would be easily added without
      // reshaping the input... so perhaps this library should just require
      // the caller to accept that the signature will be added to the top
      // level of the input

      // attach signature node to cloned input and return it
      const output = util.deepClone(input);
      delete compactProofNode['@context'];
      const proofKey = Object.keys(compactProofNode)[0];
      jsonld.addValue(output, proofKey, compactProofNode[proofKey]);
      return output;
    })();
  }

  verify(framed, options) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      options = Object.assign({}, options || {});

      const proof = framed.signature || framed.proof;
      proof['@context'] = framed['@context'];

      // destructure options
      var _options = options,
          _options$maxTimestamp = _options.maxTimestampDelta;
      let maxTimestampDelta = _options$maxTimestamp === undefined ? 15 * 60 : _options$maxTimestamp;
      var _options$checkNonce = _options.checkNonce;
      let checkNonce = _options$checkNonce === undefined ? function () {
        return proof.nonce === null || proof.nonce === undefined;
      } : _options$checkNonce;
      var _options$checkDomain = _options.checkDomain;
      let checkDomain = _options$checkDomain === undefined ? function () {
        return proof.domain === null || proof.domain === undefined;
      } : _options$checkDomain;
      var _options$checkTimesta = _options.checkTimestamp;
      let checkTimestamp = _options$checkTimesta === undefined ? function () {
        const now = Date.now();
        const delta = maxTimestampDelta * 1000;
        const created = Date.parse(proof.created);
        if (created < now - delta || created > now + delta) {
          throw new Error('The digital signature timestamp is out of range.');
        }
        return true;
      } : _options$checkTimesta;
      var _options$checkKey = _options.checkKey;
      let checkKey = _options$checkKey === undefined ? _this6.helper.checkKey.bind(_this6.helper) : _options$checkKey;
      var _options$publicKey = _options.publicKey;
      let getPublicKey = _options$publicKey === undefined ? _this6.helper.getPublicKey.bind(_this6.helper) : _options$publicKey;

      // normalize function options

      if (checkNonce === false) {
        // not checking nonce, so return true
        checkNonce = function () {
          return true;
        };
      }
      if (checkDomain === false) {
        // not checking domain, so return true
        checkDomain = function () {
          return true;
        };
      }
      if (checkTimestamp === false) {
        // not checking timestamp, so return true
        checkTimestamp = function () {
          return true;
        };
      }
      if (typeof getPublicKey !== 'function') {
        const key = getPublicKey;
        getPublicKey = function (keyId) {
          if (keyId !== key.id) {
            throw new Error('Public key not found.');
          }
          return key;
        };
      }
      checkNonce = util.normalizeAsyncFn(checkNonce, 2);
      checkDomain = util.normalizeAsyncFn(checkDomain, 2);
      checkTimestamp = util.normalizeAsyncFn(checkTimestamp, 2);
      checkKey = util.normalizeAsyncFn(checkKey, 2);
      getPublicKey = util.normalizeAsyncFn(getPublicKey, 2);

      // run nonce, domain, and timestamp checks in parallel
      const checks = yield Promise.all([checkNonce(proof.nonce, options), checkDomain(proof.domain, options), checkTimestamp(proof.date, options)]);

      if (!checks[0]) {
        throw new Error('The nonce is invalid.');
      }
      if (!checks[1]) {
        throw new Error('The domain is invalid.');
      }
      if (!checks[2]) {
        throw new Error('The timestamp is invalid.');
      }

      const keyOptions = Object.assign({}, options, {
        proof,
        keyType: _this6.requiredKeyType
      });

      // get public key
      const publicKey = yield getPublicKey(proof.creator, keyOptions);

      // TODO: should be able to override revocation check to ensure that
      // signatures made prior to the revocation check could potentially still
      // be verified

      // ensure key is not revoked
      if (publicKey.revoked !== undefined) {
        throw new Error('The document was signed with a key that has been revoked.');
      }

      // ensure key is trusted before proceeding
      const isKeyTrusted = yield checkKey(publicKey, keyOptions);
      if (!isKeyTrusted) {
        throw new Error('The document was not signed with a trusted key.');
      }

      // validate key
      yield _this6.validateKey(publicKey, keyOptions);

      // verify input
      const verifyData = yield _this6.createVerifyData(framed, Object.assign({}, options, {
        date: proof.created,
        nonce: proof.nonce,
        domain: proof.domain,
        proof
      }));

      return _this6.verifyProofNode(verifyData, proof, Object.assign({}, options, { publicKey: publicKey }));
    })();
  }

  verifyProofNode(verifyData, proof, options) {
    return _asyncToGenerator(function* () {
      throw new Error('"verifyProofNode" must be implemented in a derived class.');
    })();
  }

  // TODO: use node `crypto` and Buffers in node environment
  // returns a forge buffer
  _sha256(str, encoding) {
    // browser or other environment
    const forge = this.injector.use('forge');
    const md = forge.md.sha256.create();
    md.update(str, encoding || 'utf8');
    return md.digest();
  }
};